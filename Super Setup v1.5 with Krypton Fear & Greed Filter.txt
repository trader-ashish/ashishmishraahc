// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© mritunjaych92

//@version=5
indicator('Super Setup v1.5 with Krypton Fear & Greed Filter', overlay=true, max_labels_count=500)

// Hardcoded values for hidden parameters
candle_stability_index_param = 0.5  // Fixed value for Candle Stability Index
rsi_index_param = 70  // Fixed value for RSI Index
candle_delta_length_param = 6  // Fixed value for Candle Delta Length
disable_repeating_signals_param = input.bool(true, 'Disable Repeating Signals', group='Technical', tooltip='Removes repeating signals. Useful for removing clusters of signals and general clarity')

GREEN = #388e3c
RED =  #b22833
TRANSPARENT = color.rgb(0, 0, 0, 100)

label_size = input.string('normal', 'Label Size', options=['huge', 'large', 'normal', 'small', 'tiny'], group='Cosmetic')
label_style = input.string('text bubble', 'Label Style', ['text bubble', 'triangle', 'arrow'], group='Cosmetic')
buy_label_color = input(GREEN, 'BUY Label Color', inline='Highlight', group='Cosmetic')
sell_label_color = input(RED, 'SELL Label Color', inline='Highlight', group='Cosmetic')
label_text_color = input(color.white, 'Label Text Color', inline='Highlight', group='Cosmetic')

// ATR calculation for profit target
atr_length = input.int(14, title="ATR Length")
atr_multiplier = input.float(2.5, title="ATR Multiplier for Book Profit")
atr_value = ta.atr(atr_length)

// SMI Parameters
smi_a = input(10, 'Percent K Length', group="SMI Filter")
smi_b = input(3, 'Percent D Length', group="SMI Filter")
smi_ob = input(50, 'Overbought Level', group="SMI Filter")
smi_os = input(-50, 'Oversold Level', group="SMI Filter")

// SMI Calculations
smi_ll = ta.lowest(low, smi_a)
smi_hh = ta.highest(high, smi_a)
smi_diff = smi_hh - smi_ll
smi_rdiff = close - (smi_hh + smi_ll) / 2

smi_avgrel = ta.ema(ta.ema(smi_rdiff, smi_b), smi_b)
smi_avgdiff = ta.ema(ta.ema(smi_diff, smi_b), smi_b)
smi_signal = smi_avgdiff != 0 ? smi_avgrel / (smi_avgdiff / 2) * 100 : 0

// Filtered SMI Conditions
smi_in_oversold = smi_signal < smi_os
smi_in_overbought = smi_signal > smi_ob

// Calculations for conditions
stable_candle = math.abs(close - open) / ta.tr > candle_stability_index_param
rsi = ta.rsi(close, 14)

bullish_engulfing = close[1] < open[1] and close > open and close > open[1]
rsi_below = rsi < rsi_index_param
decrease_over = close < close[candle_delta_length_param]

bull = bullish_engulfing and stable_candle and rsi_below and decrease_over and smi_in_oversold and barstate.isconfirmed

bearish_engulfing = close[1] > open[1] and close < open and close < open[1]
rsi_above = rsi > 100 - rsi_index_param
increase_over = close > close[candle_delta_length_param]

bear = bearish_engulfing and stable_candle and rsi_above and increase_over and smi_in_overbought and barstate.isconfirmed

var last_signal = ''
var float buy_entry_price = na
var float sell_entry_price = na
var bool buy_label_plotted = false
var bool sell_label_plotted = false

if bull and (disable_repeating_signals_param ? (last_signal != 'buy' ? true : na) : true)
    buy_entry_price := close
    buy_label_plotted := false  // Reset label plotted flag when a new buy signal occurs
    if label_style == 'text bubble'
        label.new(bar_index, low, 'â–² Bottom', color=buy_label_color, style=label.style_label_up, textcolor=label_text_color, size=label_size)
    else if label_style == 'triangle'
        label.new(bar_index, low, 'â–² Bottom', yloc=yloc.belowbar, color=buy_label_color, style=label.style_triangleup, textcolor=TRANSPARENT, size=label_size)
    else if label_style == 'arrow'
        label.new(bar_index, low, 'â–² Bottom', yloc=yloc.belowbar, color=buy_label_color, style=label.style_arrowup, textcolor=TRANSPARENT, size=label_size)
    
    last_signal := 'buy'

if bear and (disable_repeating_signals_param ? (last_signal != 'sell' ? true : na) : true)
    sell_entry_price := close
    sell_label_plotted := false  // Reset label plotted flag when a new sell signal occurs
    if label_style == 'text bubble'
        label.new(bar_index, high, 'â–¼ TOP', color=sell_label_color, style=label.style_label_down, textcolor=label_text_color, size=label_size)
    else if label_style == 'triangle'
        label.new(bar_index, high, 'â–¼ TOP', yloc=yloc.abovebar, color=sell_label_color, style=label.style_triangledown, textcolor=TRANSPARENT, size=label_size)
    else if label_style == 'arrow'
        label.new(bar_index, high, 'â–¼ TOP', yloc=yloc.abovebar, color=sell_label_color, style=label.style_arrowdown, textcolor=TRANSPARENT, size=label_size)
    
    last_signal := 'sell'


// Book profit labels based on ATR, only plot once
if not na(buy_entry_price) and not buy_label_plotted
    buy_profit_target = buy_entry_price + atr_multiplier * atr_value
    if close >= buy_profit_target
        label.new(bar_index, high, "ðŸŽ¯Book Profit", color=color.blue, style=label.style_label_down, textcolor=color.white, size=label_size)
        buy_label_plotted := true  // Mark label as plotted

if not na(sell_entry_price) and not sell_label_plotted
    sell_profit_target = sell_entry_price - atr_multiplier * atr_value
    if close <= sell_profit_target
        label.new(bar_index, low, "ðŸŽ¯Book Profit", color=color.blue, style=label.style_label_up, textcolor=color.white, size=label_size)
        sell_label_plotted := true  // Mark label as plotted



// Market Structure Break (MSB) Detection

// Function to detect swing highs and lows
f_swingHighLow(_src, _len) =>
    _sw = high >= ta.highest(high, _len)
    _lw = low <= ta.lowest(low, _len)
    [_sw, _lw]

// User inputs for market structure break
var len = input.int(20, minval = 1, title = 'Loopback')
var mult = input.float(1, minval = 0.1, title = 'Multiplier')
bullish_MSB_Color = input.color(color.green, title = 'Bullish MSB Color', inline = 'Bullish MSB Style')
bearish_MSB_Color = input.color(color.red, title = 'Bearish MSB Color', inline = 'Bearish MSB Style')
bullish_MSB_Width = input.int(1, minval = 1, maxval = 5, title = 'Line Width', inline = 'Bullish MSB Style')
bearish_MSB_Width = input.int(1, minval = 1, maxval = 5, title = 'Line Width', inline = 'Bearish MSB Style')

// Calculation of swing highs and lows
[sh, sl] = f_swingHighLow(close, len)

// Identify market structure break
break_up = sh and sh[1] == false and close > high[1] * mult
break_down = sl and sl[1] == false and close < low[1] * mult

// Draw lines on market structure break
var line bullish_MSB = na
var line bearish_MSB = na
var float highest_MSB = na
var float lowest_MSB = na

if break_up
    // Find the bar_index where the swing high is and draw a line until the candle CLOSES ABOVE the market structure
    for i = 1 to 100 by 1
        if sh[i]
            bullish_MSB := line.new(bar_index[i], high[i], bar_index, high[i], color = bullish_MSB_Color, width = bullish_MSB_Width)
            highest_MSB := high[i]
            break

if break_down
    // Find the bar_index where the swing low is and draw a line until the candle CLOSES BELOW the market structure
    for i = 1 to 100 by 1
        if sl[i]
            bearish_MSB := line.new(bar_index[i], low[i], bar_index, low[i], color = bearish_MSB_Color, width = bearish_MSB_Width)
            lowest_MSB := low[i]
            break

// Calculate the 200-period EMA
ema200 = ta.ema(close, 200)

// Plot the 200 EMA
plot(ema200, title = '200 EMA', color = color.red, linewidth = 2)

// VWAP calculation
vwapValue = ta.vwap(close)

// Plot VWAP line
plot(vwapValue, title = 'VWAP', color = color.black, linewidth = 2)

// Alerts
alertcondition(bull, 'BUY Signals', 'New signal: BUY')
alertcondition(bear, 'SELL Signals', 'New signal: SELL')


res = input.timeframe(title = 'Resolution', defval = 'D', options = ['D', 'W', 'M'])
ShowLines = input.bool(true, title = 'Show Lines', tooltip = 'if not ticked, then scale values will disappear too')
LineTransparency = input.int(50, title = 'line transparency', tooltip = 'set this to 100 to hide the lines on the chart completely but retain the scale labels')
ShowLabels = input.bool(true, 'Show Markers')
MarkerTransparency = input.int(31, title = 'marker transparency', tooltip = 'this sets transparency of the marker, which by default is a cross')


sizeOption = input.string(title = 'Label Size', options = ['Auto', 'Huge', 'Large', 'Normal', 'Small', 'Tiny'], defval = 'Small')
baroffset = input.int(title = 'label offset', defval = -8)


color_res = input.color(color.red, 'Resistance Lines Labels Color', group = 'Style Settings')
color_sup = input.color(color.green, 'Support Lines Labels Color', group = 'Style Settings')


xHigh = request.security(syminfo.tickerid, res, high[1], lookahead = barmerge.lookahead_on)
xLow = request.security(syminfo.tickerid, res, low[1], lookahead = barmerge.lookahead_on)
xClose = request.security(syminfo.tickerid, res, close[1], lookahead = barmerge.lookahead_on)

R4 = 0.55 * (xHigh - xLow) + xClose
R3 = 0.275 * (xHigh - xLow) + xClose


S3 = xClose - 0.275 * (xHigh - xLow)
S4 = xClose - 0.55 * (xHigh - xLow)

plot(ShowLines ? math.round_to_mintick(R3) : na, 'R3', color.new(color_res, LineTransparency), style = plot.style_circles, linewidth = 2)
plot(ShowLines ? math.round_to_mintick(R4) : na, 'R4', color.new(color_res, LineTransparency), style = plot.style_circles, linewidth = 2)


plot(ShowLines ? math.round_to_mintick(S3) : na, 'S3', color.new(color_sup, LineTransparency), style = plot.style_circles, linewidth = 2)
plot(ShowLines ? math.round_to_mintick(S4) : na, 'S4', color.new(color_sup, LineTransparency), style = plot.style_circles, linewidth = 2)


//labels

labelSize = sizeOption == 'Huge' ? size.huge : sizeOption == 'Large' ? size.large : sizeOption == 'Small' ? size.small : sizeOption == 'Tiny' ? size.tiny : sizeOption == 'Auto' ? size.auto : size.normal

S3Label = ShowLabels ? label.new(x = bar_index - baroffset, y = S3, text = 'S3', color = color.new(color_sup, MarkerTransparency), textcolor = color.white, style = close > S3 ? label.style_label_up : label.style_label_down, size = labelSize) : na

label.delete(S3Label[1])



S4Label = ShowLabels ? label.new(x = bar_index - baroffset, y = S4, text = 'S4', color = color.new(color_sup, MarkerTransparency), textcolor = color.white, style = close > S4 ? label.style_label_up : label.style_label_down, size = labelSize) : na

label.delete(S4Label[1])



R3Label = ShowLabels ? label.new(x = bar_index - baroffset, y = R3, text = 'R3', color = color.new(color_res, MarkerTransparency), textcolor = color.white, style = close > R3 ? label.style_label_up : label.style_label_down, size = labelSize) : na

label.delete(R3Label[1])


R4Label = ShowLabels ? label.new(x = bar_index - baroffset, y = R4, text = 'R4', color = color.new(color_res, MarkerTransparency), textcolor = color.white, style = close > R4 ? label.style_label_up : label.style_label_down, size = labelSize) : na

label.delete(R4Label[1])


//alerts


//set alerts for each ATR Timeframe
alertcondition(ta.cross(close, R3), 'R3 Tag', message = 'R3 Tag {{close}} {{timeframe}}')
alertcondition(ta.cross(close, R4), 'R4 Tag', message = 'R4 Tag {{close}} {{timeframe}}')
alertcondition(ta.cross(close, S3), 'S3 Tag', message = 'S3 Tag {{close}} {{timeframe}}')
alertcondition(ta.cross(close, S4), 'S4 Tag', message = 'S4 Tag {{close}} {{timeframe}}')

