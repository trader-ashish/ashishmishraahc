//@version=5
bbars = input.int(title='Number of Bars', defval=150, minval=1, maxval=500)
cnum = input.int(title='Row Size', defval=24, minval=5, maxval=100)
percent = input.float(100., title='Value Area Volume %', minval=0, maxval=100)
poc_color = input.color(defval=#ffffff57, title='POC Color', inline='poc')
poc_width = input.int(defval=2, title='Width', minval=1, maxval=5, inline='poc')
vup_color = input(defval=color.new(color.blue, 30), title='Value Area Up')
vdown_color = input(defval=color.new(color.orange, 30), title='Value Area Down')
up_color = input(defval=color.new(color.blue, 75), title='UP Volume')
down_color = input(defval=color.new(color.orange, 75), title='Down Volume')
show_poc = input.bool(defval = false, title = "Show POC Label")

top = ta.highest(bbars)
bot = ta.lowest(bbars)
dist = (top - bot) / 500
step = (top - bot) / cnum

// calculate/keep channel levels
levels5 = array.new_float(cnum + 1)
for x = 0 to cnum by 1
    array.set(levels5, x, bot + step * x)

// get the volume if there is intersection
get_vol(y11, y12, y21, y22, height, vol) =>
    nz(math.max(math.min(math.max(y11, y12), math.max(y21, y22)) - math.max(math.min(y11, y12), math.min(y21, y22)), 0) * vol / height)

if barstate.islast
    // calculate/get volume for each channel and candle
    volumes = array.new_float(cnum * 2, 0.)
    for bars = 0 to bbars - 1 by 1
        body_top = math.max(close[bars], open[bars])
        body_bot = math.min(close[bars], open[bars])
        itsgreen = close[bars] >= open[bars]

        topwick = high[bars] - body_top
        bottomwick = body_bot - low[bars]
        body = body_top - body_bot

        bodyvol = body * volume[bars] / (2 * topwick + 2 * bottomwick + body)
        topwickvol = 2 * topwick * volume[bars] / (2 * topwick + 2 * bottomwick + body)
        bottomwickvol = 2 * bottomwick * volume[bars] / (2 * topwick + 2 * bottomwick + body)
        for x = 0 to cnum - 1 by 1
            array.set(volumes, x, array.get(volumes, x) + (itsgreen ? get_vol(array.get(levels5, x), array.get(levels5, x + 1), body_bot, body_top, body, bodyvol) : 0) + get_vol(array.get(levels5, x), array.get(levels5, x + 1), body_top, high[bars], topwick, topwickvol) / 2 + get_vol(array.get(levels5, x), array.get(levels5, x + 1), body_bot, low[bars], bottomwick, bottomwickvol) / 2)
            array.set(volumes, x + cnum, array.get(volumes, x + cnum) + (itsgreen ? 0 : get_vol(array.get(levels5, x), array.get(levels5, x + 1), body_bot, body_top, body, bodyvol)) + get_vol(array.get(levels5, x), array.get(levels5, x + 1), body_top, high[bars], topwick, topwickvol) / 2 + get_vol(array.get(levels5, x), array.get(levels5, x + 1), body_bot, low[bars], bottomwick, bottomwickvol) / 2)

    totalvols = array.new_float(cnum, 0.)
    for x = 0 to cnum - 1 by 1
        array.set(totalvols, x, array.get(volumes, x) + array.get(volumes, x + cnum))

    int poc = array.indexof(totalvols, array.max(totalvols))

    // calculate value area
    totalmax = array.sum(totalvols) * percent / 100.
    va_total = array.get(totalvols, poc)
    int up = poc
    int down = poc
    for x = 0 to cnum - 1 by 1
        if va_total >= totalmax
            break
        uppervol = up < cnum - 1 ? array.get(totalvols, up + 1) : 0.
        lowervol = down > 0 ? array.get(totalvols, down - 1) : 0.
        if uppervol == 0 and lowervol == 0
            break
        if uppervol >= lowervol
            va_total += uppervol
            up += 1
            up
        else
            va_total += lowervol
            down -= 1
            down

    maxvol = array.max(totalvols)
    for x = 0 to cnum * 2 - 1 by 1
        array.set(volumes, x, array.get(volumes, x) * bbars / (3 * maxvol))


    // Draw VP rows
    var vol_bars = array.new_box(cnum * 2, na)
    for x = 0 to cnum - 1 by 1
        box.delete(array.get(vol_bars, x))
        box.delete(array.get(vol_bars, x + cnum))
        array.set(vol_bars, x, box.new(bar_index - bbars + 1, 
                                       array.get(levels5, x + 1) - dist, 
                                       bar_index - bbars + 1 + math.round(array.get(volumes, x)), 
                                       array.get(levels5, x) + dist, 
                                       border_width=0, 
                                       bgcolor=x >= down and x <= up ? vup_color : up_color))
        array.set(vol_bars, x + cnum, box.new(bar_index - bbars + 1 + math.round(array.get(volumes, x)), 
                                              array.get(levels5, x + 1) - dist, 
                                              bar_index - bbars + 1 + math.round(array.get(volumes, x)) + math.round(array.get(volumes, x + cnum)), 
                                              array.get(levels5, x) + dist, 
                                              border_width=0, 
                                              bgcolor=x >= down and x <= up ? vdown_color : down_color))

    // Draw POC line and label
    poc_level = (array.get(levels5, poc) + array.get(levels5, poc + 1)) / 2
    var line poc_line = na
    line.delete(poc_line)
    poc_line := line.new(bar_index - bbars + 1, poc_level, bar_index - bbars + 2, poc_level, extend=extend.right, color=poc_color, width=poc_width)
    
    if show_poc
        var label poc_label = na
        label.delete(poc_label)
        poc_label := label.new(bar_index + 15, poc_level, 
                               text = "POC: " + str.tostring(math.round_to_mintick(poc_level)),
                               style = close >= poc_level ? label.style_label_up : label.style_label_down)


//Gathers User Inputs

dashOn = input(true, 'Dashboard On / Off')


dashDist = input(93, 'Dashboard Distance')
dashColor = input.color(color.new(#000000, 0), 'Dashboard Color', inline='Dash Line')
dashTextColor = input.color(color.new(#00c8ff, 0), 'Text Color', inline='Dash Line')

//Calculates Volatility for Dashboard
atr9 = ta.atr(14)
stdAtr = 2 * ta.stdev(atr9, 20)
smaAtr = ta.sma(atr9, 20)
topAtrDev = smaAtr + stdAtr
bottomAtrDev = smaAtr - stdAtr
calcDev = (atr9 - bottomAtrDev) / (topAtrDev - bottomAtrDev)
percentVol = 40 * calcDev + 30

//Calculates Volume for Dashboard
volumeDash = volume

//RSI for Dashboard
rsiDash = ta.rsi(close, 14)

//Calculates Sentiment for Dashboard
ema9 = ta.ema(close, 9)
totalSentTxt = ema9 > ema9[2] ? 'Bullish' : ema9 < ema9[2] ? 'Bearish' : 'Flat'

//Defines Each Timeframe for Trend Panel
sma = ta.sma(close, 50)
oneM = request.security(syminfo.tickerid, '1', sma, barmerge.gaps_off, barmerge.lookahead_off)
fiveM = request.security(syminfo.tickerid, '5', sma, barmerge.gaps_off, barmerge.lookahead_off)
fifteenM = request.security(syminfo.tickerid, '15', sma, barmerge.gaps_off, barmerge.lookahead_off)
thirtyM = request.security(syminfo.tickerid, '30', sma, barmerge.gaps_off, barmerge.lookahead_off)
oneH = request.security(syminfo.tickerid, '60', sma, barmerge.gaps_off, barmerge.lookahead_off)
twoH = request.security(syminfo.tickerid, '120', sma, barmerge.gaps_off, barmerge.lookahead_off)
fourH = request.security(syminfo.tickerid, '240', sma, barmerge.gaps_off, barmerge.lookahead_off)
weekly = request.security(syminfo.tickerid, 'W', sma, barmerge.gaps_off, barmerge.lookahead_off)
monthly = request.security(syminfo.tickerid, 'M', sma, barmerge.gaps_off, barmerge.lookahead_off)
daily = request.security(syminfo.tickerid, 'D', sma, barmerge.gaps_off, barmerge.lookahead_off)

//Defines An Uptrend for Trend Panel
oneMUp = oneM > oneM[1]
fiveMUp = fiveM > fiveM[1]
fifteenMUp = fifteenM > fifteenM[1]
thirtyMUp = thirtyM > thirtyM[1]
oneHUp = oneH > oneH[1]
twoHUp = twoH > twoH[1]
fourHUp = fourH > fourH[1]
weeklyUp = weekly > weekly[1]
monthlyUp = monthly > monthly[1]
dailyUp = daily > daily[1]

//Checks if the Current State is an Uptrend or Downtrend for the Trend Panel
up7 = 'üü¢'
down = 'üî¥'
oneMTrend = oneMUp ? up7 : down
fiveMTrend = fiveMUp ? up7 : down
fifteenMTrend = fifteenMUp ? up7 : down
thirtyMTrend = thirtyMUp ? up7 : down
oneHTrend = oneHUp ? up7 : down
twoHTrend = twoHUp ? up7 : down
fourHTrend = fourHUp ? up7 : down
weeklyTrend = weeklyUp ? up7 : down
monthlyTrend = monthlyUp ? up7 : down
dailyTrend = dailyUp ? up7 : down













if dashOn
    label lemonLabel = label.new(time, close, text='‚òÅÔ∏è TABLETA MEGA POWER V3  ‚òÅÔ∏è' + '\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ' + '\n         ‚Ää‚Ääüíµ informacion de mercado üíµ' + '\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ' + '\nüü°‚Ää‚Ää‚ÄäVolatilidad              ‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää| ' + str.tostring(percentVol, '##.##') + '%' + '\nüü° Volumen               ‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää| ' + str.tostring(volumeDash, '##.##') + '\nüü° RSI                   ‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää| ' + str.tostring(rsiDash, '##.##') + '\nüü° Sentimiento mercado | ' + totalSentTxt + '\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ' + '\n               üìà Trend Panel üìâ' + '\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ' + '\n     1 Minute | ' + oneMTrend + '         2 Hour | ' + twoHTrend + '\n     5 Minute | ' + fiveMTrend + '         4 Hour | ' + fourHTrend + '\n  ‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää15 Minute | ' + fifteenMTrend + '        ‚ÄäWeekly | ' + weeklyTrend + '\n  ‚Ää‚Ää‚Ää‚Ää‚Ää‚Ää30 Minute | ' + thirtyMTrend + '       Monthly |‚Ää‚Ää‚Ää‚Ää‚Ää' + monthlyTrend + '\n        1 Hour | ' + oneHTrend + '         ‚Äâ‚Äâ‚Ää‚Ää‚Ää‚Ää‚ÄäDaily | ' + dailyTrend + '\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ' + '\n                     üî±CRIPTOM4N üî±', color=dashColor, xloc=xloc.bar_time, style=label.style_label_left, textcolor=dashTextColor, textalign=text.align_left)
    
    label.set_x(lemonLabel, label.get_x(lemonLabel) + math.round(ta.change(time) * dashDist))
    label.delete(lemonLabel[1])

 








// Inputs EMA
src = input(close, title='Tipo EMA')
len = input.int(minval=1, defval=200, title='EMA 200')
ema_color = input(color.rgb(255, 242, 0), title="Color de la EMA")  // Nuevo input para el color de la EMA

// C√°lculo
ema = ta.ema(src, len)

// Determinaci√≥n de se√±ales
long = close > ema
short = close < ema

// Plot de la EMA con el color personalizado
plot(ema, color=ema_color, title="EMA")
plot(ema)


//
ShowPAC = input(false, title='Show EMA Wave')
ShowBarColor = input(true, title='Show Coloured GRaB Candles')

PACLen = input.int(34, minval=2, title='EMA Wave Length (34 by default)')
src2 = input(close, title='Source for Wave centre EMA')

// --- CONSTANTS ---
DodgerBlue = #1e8fff

// === /INPUTS ===
// Constants colours that include fully non-transparent option.
green100 = #00FF00FF
lime100 = #00FF00FF
red100 = #FF0000FF
blue100 = color.rgb(255, 255, 255)
aqua100 = color.rgb(255, 255, 255)
darkred100 = #FF0000FF

// === SERIES SETUP ===

// Price action channel (Wave)
pacCe = ta.ema(src, PACLen)
pacLo = ta.ema(low, PACLen)
pacHi = ta.ema(high, PACLen)


// === /SERIES ===

// === PLOTTING ===
// 
// If selected, Plot the Wave Channel based on EMA high,low and close
L = plot(ShowPAC ? pacLo : na, color=color.new(color.red, 20), linewidth=1, title='High Wave EMA')
H = plot(ShowPAC ? pacHi : na, color=color.new(color.green, 20), linewidth=1, title='Low Wave EMA')
C = plot(ShowPAC ? pacCe : na, color=color.new(color.black, 20), linewidth=1, title='Centre Wave EMA')
fill(L, H, color=color.new(color.gray, 9), title='Fill Channel')

// Colour bars according to the close position relative to the PAC selected.
bColour = close >= open ? close >= pacHi ? lime100 : close <= pacLo ? red100 : aqua100 : close >= pacHi ? green100 : close <= pacLo ? darkred100 : blue100
barcolor(ShowBarColor ? bColour : na, title='Bar Colours')



 
//------------------ AI Signals | https://www.getaisignals.com ---------------//
// Get user input
sensitivity = input.string("Low", "Sensitivity", ["Low", "Medium", "High"])
suppRes     = input.bool(false, "Support & Resistance")
breaks      = input.bool(false, "Breaks")
usePsar     = input.bool(false, "PSAR")
emaEnergy   = input.bool(true, "EMA Energy")
channelBal  = input.bool(true, "Channel Balance")
autoTL      = input.bool(false, "Auto Trend Lines")
// Functions
supertrend(_src, factor, atrLen) =>
    atr = ta.atr(atrLen)
    upperBand = _src + factor * atr
    lowerBand = _src - factor * atr
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])
    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
    int direction = na
    float superTrend = na
    prevSuperTrend = superTrend[1]
    if na(atr[1])
        direction := 1
    else if prevSuperTrend == prevUpperBand
        direction := close > upperBand ? -1 : 1
    else
        direction := close < lowerBand ? 1 : -1
    superTrend := direction == -1 ? lowerBand : upperBand
    [superTrend, direction]
lr_slope(_src, _len) =>
    x = 0.0, y = 0.0, x2 = 0.0, xy = 0.0
    for i = 0 to _len - 1
        val = _src[i]
        per = i + 1
        x += per
        y += val
        x2 += per * per
        xy += val * per
    _slp = (_len * xy - x * y) / (_len * x2 - x * x)
    _avg = y / _len
    _int = _avg - _slp * x / _len + _slp
    [_slp, _avg, _int]
lr_dev(_src, _len, _slp, _avg, _int) =>
    upDev = 0.0, dnDev = 0.0
    val = _int
    for j = 0 to _len - 1
        price = high[j] - val
        if price > upDev
            upDev := price
        price := val - low[j]
        if price > dnDev
            dnDev := price
        price := _src[j]
        val += _slp
    [upDev, dnDev]
// Get Components
ocAvg       = math.avg(open, close)
sma1        = ta.sma(close, 8)
sma2        = ta.sma(close, 9)
sma3        = ta.sma(close, 10)
sma4        = ta.sma(close, 11)
sma5        = ta.sma(close, 12)
sma6        = ta.sma(close, 13)
sma7        = ta.sma(close, 14)
sma8        = ta.sma(close, 15)
sma9        = ta.sma(close, 15)

psar        = ta.sar(0.02, 0.02, 0.2)
[middleKC1, upperKC1, lowerKC1] = ta.kc(close, 80, 10.5)
[middleKC2, upperKC2, lowerKC2] = ta.kc(close, 80, 9.5)
[middleKC3, upperKC3, lowerKC3] = ta.kc(close, 80, 8)
[middleKC4, upperKC4, lowerKC4] = ta.kc(close, 80, 3)
[supertrend, direction] = supertrend(close, sensitivity == "Low" ? 5 : sensitivity == "Medium" ? 2.5 : 2, 11)
barsL       = 10
barsR       = 10
pivotHigh = fixnan(ta.pivothigh(barsL, barsR)[1])
pivotLow = fixnan(ta.pivotlow(barsL, barsR)[1])
source = close, period = 150
[s, a, i] = lr_slope(source, period)
[upDev, dnDev] = lr_dev(source, period, s, a, i)
// Colors
green       = #1ab3d5, green2   = #00DD00
red         = #e4ab1a, red2     = #DD0000
emaEnergyColor(ma) => emaEnergy ? (close >= ma ? green : red) : na
// Plots
k1 = plot(ta.ema(upperKC1, 50), "", na, editable=false)
k2 = plot(ta.ema(upperKC2, 50), "", na, editable=false)
k3 = plot(ta.ema(upperKC3, 50), "", na, editable=false)
k4 = plot(ta.ema(upperKC4, 50), "", na, editable=false)
k5 = plot(ta.ema(lowerKC4, 50), "", na, editable=false)
k6 = plot(ta.ema(lowerKC3, 50), "", na, editable=false)
k7 = plot(ta.ema(lowerKC2, 50), "", na, editable=false)
k8 = plot(ta.ema(lowerKC1, 50), "", na, editable=false)
fill(k1, k2, channelBal ? color.new(red2, 40) : na, editable=false)
fill(k2, k3, channelBal ? color.new(red2, 65) : na, editable=false)
fill(k3, k4, channelBal ? color.new(red2, 90) : na, editable=false)
fill(k5, k6, channelBal ? color.new(green2, 90) : na, editable=false)
fill(k6, k7, channelBal ? color.new(green2, 65) : na, editable=false)
fill(k7, k8, channelBal ? color.new(green2, 40) : na, editable=false)
plot(sma1, "", emaEnergyColor(sma1), editable=false)
plot(sma2, "", emaEnergyColor(sma2), editable=false)
plot(sma3, "", emaEnergyColor(sma3), editable=false)
plot(sma4, "", emaEnergyColor(sma4), editable=false)
plot(sma5, "", emaEnergyColor(sma5), editable=false)
plot(sma6, "", emaEnergyColor(sma6), editable=false)
plot(sma7, "", emaEnergyColor(sma7), editable=false)
plot(sma8, "", emaEnergyColor(sma8), editable=false)
plot(sma9, "", emaEnergyColor(sma9), editable=false)



p3 = plot(ocAvg, "", na, editable=false)
p4 = plot(psar, "PSAR", usePsar ? (close > psar ? green : red) : na, 1, plot.style_circles, editable=false)
fill(p3, p4, usePsar ? (close > psar ? color.new(green, 90) : color.new(red, 90)) : na, editable=false)
y1 = low - (ta.atr(30) * 1.6), y1B = low - ta.atr(30)
y2 = high + (ta.atr(30) * 1.6), y2B = high + ta.atr(30)
bull = ta.crossover(close, supertrend) and close >= sma9
bear = ta.crossunder(close, supertrend) and close <= sma9
buy  = bull ? label.new(bar_index, y1, "‚ñ≤", xloc.bar_index, yloc.price, #102bf8, label.style_label_up, color.white, size.normal) : na
sell = bear ? label.new(bar_index, y2, "‚ñº", xloc.bar_index, yloc.price, #b4060d, label.style_label_down, color.white, size.normal) : na
plot(pivotHigh, "Resistance", not suppRes or ta.change(pivotHigh) ? na : red, 2, offset=-(barsR + 1), editable=false)
plot(pivotLow, "Support", not suppRes or ta.change(pivotLow) ? na : green, 2, offset=-(barsR + 1), editable=false)
upB = breaks and ta.crossover(close, pivotHigh) ? label.new(bar_index, y1B, "B", xloc.bar_index, yloc.price, green, label.style_label_up, color.white, size.small) : na
dnB = breaks and ta.crossunder(close, pivotLow) ? label.new(bar_index, y2B, "B", xloc.bar_index, yloc.price, red, label.style_label_down, color.white, size.small) : na
x1 = bar_index - period + 1, _y1 = i + s * (period - 1), x2 = bar_index, _y2 = i
upperTL = autoTL ? line.new(x1, _y1 + upDev, x2, _y2 + upDev, xloc.bar_index, extend.none, red) : na
line.delete(upperTL[1])
middleTL = autoTL ? line.new(x1, _y1, x2, _y2, xloc.bar_index, extend.none, color.white) : na
line.delete(middleTL[1])
lowerTL = autoTL ? line.new(x1, _y1 - dnDev, x2, _y2 - dnDev, xloc.bar_index, extend.none, green) : na
line.delete(lowerTL[1])
// Alerts
// alertcondition(bull or bear or ta.crossover(close, pivotHigh) or ta.crossunder(close, pivotLow), "Alert Any", "AI Signals Platinum\nAlert Triggered on {{ticker}} @ {{close}}")
// alertcondition(bull, "Alert Buy", "AI Signals Platinum\nBuy {{ticker}} @ {{close}}")
// alertcondition(bear, "Alert Sell", "AI Signals Platinum\nSell {{ticker}} @ {{close}}")
// alertcondition(ta.crossover(close, pivotHigh), "Broke Resistance", "AI Signals Platinum\nBroke Resistance on {{ticker}} @ {{close}}")
// alertcondition(ta.crossunder(close, pivotLow), "Broke Support", "AI Signals Platinum\nBroke Support on {{ticker}} @ {{close}}")
// Module  - Signals - SL - TPS mejora enviada por: comgunner
//-----------------------------------------

//@version=5
indicator("[Yurecc] NOSTRADAMUS"
  , overlay = true
  , max_labels_count = 500
  , max_lines_count = 500
  , max_boxes_count = 500
  , max_bars_back = 500)

//======================================================================================= 
// MODULO DE SE√ëALES PARA MEGA POWER 
//======================================================================================= 
indicator_name = "Simplealgo.io - MEGAPOWER "
//======================================================================================= 
changeCond =  bull  or bear //NECESARIO PARA EL MODULO DE TPS 
//======================================================================================= 
 


// Module  - Signals - SL - TPS by @comgunner
//-----------------------------------------
//*********************************************************
//*                     Module                            *
//*              Signals - SL - TPSEND                    *
//*********************************************************
// C√°lculos

groupEnTpSl = "======= Module - Signals ======="
plot(na)

levels_tip = "Habilita etiquetas compra/venta /SL"
atrLen_tip = "Atr para el Calculo de Stoploss y TakeProfit"
atrRisk_tip = " ATR Risk Multiplier: Recommended 1.5 or 1.9 / Multiplicador de Riesgo ATR: Recomendado 1.5 o 1.9"
tpLen_tip = "Distance in percentage between TakeProfits / Distancia en porcentaje entre TakeProfits"
tpSL_tip = "Distance in percentage for SL / Distancia en porcentaje para SL"

numTP_tip = " Number of Take Profit Levels, min 1 max 10 / N√∫mero de niveles de toma de ganancias, m√≠nimo 1 m√°ximo 10 "
numTP = input.int(3, "Number of Take Profit Levels üé±", minval=1, maxval=5,tooltip =numTP_tip ,group=groupEnTpSl)

PercentOrATR_tip="Select the calculation method for TakeProfits / Selecciona el metodo de calculo para los TakeProfits" 

var string PercentOrATR = input.string("ATR", "Calculation method for TakeProfit (% or ATR)", options=["ATR", "PERCENTAGE","PREDICTUM"], inline="TPS", group=groupEnTpSl,tooltip=PercentOrATR_tip)

levels = input(title='Show Entry Labels/SL/TP /Mostrar Etiquetas de Entrada/SL/TP', defval=true, group=groupEnTpSl, tooltip=levels_tip) 

atrLen   = input.int(14, "ATR Length TP", group=groupEnTpSl, tooltip=atrLen_tip)
atrRisk  = input.float(1.0, "Riesgo trade", group=groupEnTpSl,tooltip=atrRisk_tip )
tpLen = input.float(2.0, "TP [%] üé±", step=0.1, group=groupEnTpSl, tooltip=tpLen_tip)
tpLenpre_tip = "Initial TP for Predictum type calculation / TP inicial para el c√°lculo del tipo Predictum"
tpLenpre = input.float(0.5, "TP Initial Predictum [%] üé±", minval=0.3, step=0.1, group=groupEnTpSl, tooltip=tpLenpre_tip)
tpSL = input.float(3.0, "SL [%] üíÄÔ∏è", step=0.1, group=groupEnTpSl, tooltip=tpSL_tip)
lvlDecimals = input.int(3, "Decimals", 1, 16, inline="lvlDecimals",group=groupEnTpSl)
decimals = lvlDecimals == 1 ? "#.#" : lvlDecimals == 2 ? "#.##" : lvlDecimals == 3 ? "#.###" : lvlDecimals == 4 ? "#.####" : lvlDecimals == 5 ? "#.#####" : lvlDecimals == 6 ? "#.######" : lvlDecimals == 7 ? "#.#######" : lvlDecimals == 8 ? "#.########" : lvlDecimals == 9 ? "#.#########" : lvlDecimals == 10 ? "#.##########" : lvlDecimals == 11 ? "#.###########" : lvlDecimals == 12 ? "#.############" : lvlDecimals == 13 ? "#.#############" : lvlDecimals == 14 ? "#.##############" : lvlDecimals == 15 ? "#.###############" : "#.################"

lvlLines    = input.bool(true, "Show TP/SL lines ? / Mostart Lineas TP/SL? ", inline="levels2",group=groupEnTpSl)
linesStyle  = input.string("DOTTED", "", ["SOLID", "DASHED", "DOTTED"], inline="levels2",group=groupEnTpSl)
lvlDistance = input.int(3, "Distance / Distancia", 1, inline="levels2",group=groupEnTpSl)
stylelvl = linesStyle == "SOLID" ? line.style_solid : linesStyle == "DASHED" ? line.style_dashed : line.style_dotted
lvlLinesw = input.int(title=' TP/SL Line Thickness / Grosor de l√≠nea TP/SL', defval=1, minval=1,inline="levels2",group=groupEnTpSl)
filllvlLines  = input.int(79, "Fill TP/SL Line Alpha %", minval=1, maxval=98,group=groupEnTpSl, inline="levels2")
filllvlLineson    = input.bool(true, "Show TP/SL Fill lines ? / Mostart Relleno Lineas TP/SL? ", inline="levels2",group=groupEnTpSl)



trigger = bull  ? 1 : 0
atrBand = ta.atr(atrLen) * atrRisk
atrStop = trigger == 1 ? low - atrBand : high + atrBand






lastTrade(src) => ta.valuewhen(changeCond, src, 0 )

//Nuevo, distancia de TP's

DistanceTp =  close * tpLen / 100 
Distance_CTp = trigger == 1 ? close - DistanceTp : close + DistanceTp


DistanceSL =  close * tpSL / 100 
Distance_CSL = trigger == 1 ? low - DistanceSL : high + DistanceSL

DistanceTppre =  close * tpLenpre / 100 
Distance_CTpre = trigger == 1 ? close - DistanceTppre : close + DistanceTppre



var float atrSL = na

if PercentOrATR == "ATR"
    atrStop := atrStop
    atrSL := atrStop
else
    // L√≥gica para las opciones "PERCENTAGE" y "PREDICTUM"
    if PercentOrATR == "PERCENTAGE"
        atrStop := Distance_CTp
        atrSL := Distance_CSL
    else if PercentOrATR == "PREDICTUM"
        atrStop := Distance_CTpre  // Ajusta seg√∫n tu l√≥gica espec√≠fica para "PREDICTUM"
        atrSL := Distance_CSL
        //numTP := 8

//CONTADOR DE VELAS, APARTIR E LA ULTIMA ENTRADA trigger o changeCondPNL = nz(alertLongPNL, false) != nz(alertShortPNL, false)

var int countOfCandles = 0

if trigger
    countOfCandles := 0
else
    countOfCandles := na(countOfCandles) ? 0 : countOfCandles + 1




//ENTRADA
entry = levels ? label.new(time, close, "ENTRY  üôà " + str.tostring(lastTrade(close), decimals), xloc.bar_time, yloc.price, color.rgb(0, 145, 255), label.style_label_left, color.white, size.normal) : na
label.set_x(entry, label.get_x(entry) + math.round(ta.change(time) * lvlDistance))
label.set_y(entry, lastTrade(close))
label.delete(entry[1])


lineEntry = levels and lvlLines ? line.new(bar_index - countOfCandles, lastTrade(close), bar_index + lvlDistance ,lastTrade(close), xloc.bar_index, extend.none, color.rgb(0, 145, 255),stylelvl, width=lvlLinesw ) : na
line.delete(lineEntry[1])

//StopLoss
stop_y = lastTrade(atrSL)
stop  = levels ? label.new(time, close, "STOP LOSSüíÄÔ∏è : " + str.tostring(stop_y, decimals), xloc.bar_time, yloc.price, red2, label.style_label_left, color.white, size.normal) : na
label.set_x(stop, label.get_x(stop) + math.round(ta.change(time) * lvlDistance))
label.set_y(stop, stop_y)
label.delete(stop[1])
plot( stop_y , title="SL" ,editable = false , color = #ffffff00)

linestop = levels and lvlLines ? line.new(bar_index - countOfCandles, stop_y, bar_index + lvlDistance ,stop_y, xloc.bar_index, extend.none,red2,stylelvl, width=lvlLinesw ) : na
line.delete(linestop[1]) // Corregido aqu√≠



// FILLING
if filllvlLineson
    linefill.new(linestop, lineEntry, color = color.new(color.red, filllvlLines))

ico_dir = stop_y < close ? "üìà" : "üìâ"



// Array para almacenar las etiquetas y l√≠neas
var label[] tpLabels = array.new_label(0)
var line[] tpLines = array.new_line(0)

//################################################################

MovingTarget_tip = "Strategy to move StopLoss (BE), when it reaches a TP / Estrategia para mover StopLoss (BE), cuando alcanza un TP "
showLabel_tip = "Show SIGNAL GENERATOR label / Mostrar etiqueta SIGNAL GENERATOR"
MovingTarget = input.int(2, title="Moving Target (BE)", minval=1,group=groupEnTpSl,inline="SignalG",tooltip=MovingTarget_tip)
showLabel = input(false, title="Showlabel Signal Generator",group=groupEnTpSl,inline="SignalG",tooltip=showLabel_tip)

tf = timeframe.period
//miSimbolo = ticker.standard(syminfo.tickerid)





//========================================================================

buy_label = ' =====SIGNAL GENERATOR======\n'
buy_label := buy_label + '=========KAKUPAKAT=========\n' 

buy_label := buy_label + ' \n' 

buy_label := buy_label + 'COIN ü™ô : ' + '' + str.tostring(syminfo.ticker)+ '\n\n'
buy_label := buy_label + 'TIMEFRAME ‚è∞ : ' + '' + str.tostring(tf)+ '\n'
buy_label := buy_label + ' \n' 
buy_label := buy_label + 'Dir: '+ str.tostring(ico_dir)  + '' + (stop_y < lastTrade(close) ? 'LONG' : 'SHORT') + '\n'
buy_label := buy_label + 'Entry üöÄ: ' + '' + str.tostring(lastTrade(close), decimals) +'\n\n'


//*********************************************************
// Funci√≥n para crear TP y l√≠neas by CoMgUnNeR 
// ¬°Codigo mas simplificado da creditos al autor! me costo bastante.
//*********************************************************

// Funci√≥n para crear TP y l√≠neas
// Funci√≥n para calcular potencias
pow(base, exponent) =>
    var float result = 1.0
    for i = 1 to exponent
        result := result * base
    result

var float[] tpValues = array.new_float(0)

// Funci√≥n para crear TP y l√≠neas
createTP(level) =>
    if levels
        var float tp_y = na
        var string emoji = na
        var color textColor = na
        var color lineColor = na
        var line tpLinePrev = na

        
        if PercentOrATR == "PREDICTUM"
            if level == 1
                tp_y := (lastTrade(close) - lastTrade(atrStop)) * level + lastTrade(close)
            else
                tp_y := tp_y + (tp_y - lastTrade(close)) * 0.618  
            
            emoji := level == numTP ? "üé±üé±" : "üé±"
            textColor := #000000
            lineColor := #51ff00
        else
            tp_y := (lastTrade(close) - lastTrade(atrStop)) * level + lastTrade(close)
            emoji := level == numTP ? "üé±üé±" : "üé±"
            textColor := #000000
            lineColor := #51ff00

        tp = label.new(time, tp_y, "TP" + str.tostring(level) + ") "  + str.tostring(tp_y, decimals) + " | " + emoji , xloc.bar_time , yloc.price, color=lineColor, style=label.style_label_left, textcolor=textColor, size=size.normal)
        label.set_x(tp, label.get_x(tp) + math.round(ta.change(time) * lvlDistance))
        array.push(tpLabels, tp)

        if lvlLines
            tpLine = line.new(bar_index - countOfCandles, tp_y, bar_index + lvlDistance, tp_y, xloc.bar_index, extend.none, lineColor, stylelvl, width=lvlLinesw)
            array.push(tpLines, tpLine)
            if array.size(tpLines) > numTP
                line.delete(array.get(tpLines, 0))
                array.shift(tpLines)
                if filllvlLineson
                    if level == 1
                        
                        linefill.new(lineEntry, tpLine, color = color.new(color.green, filllvlLines))
                        tpLinePrev := tpLine
                    else
                        linefill.new(tpLinePrev, tpLine, color = color.new(color.green, filllvlLines))
                        tpLinePrev := tpLine   

        if array.size(tpLabels) > numTP
            label.delete(array.get(tpLabels, 0))
            array.shift(tpLabels)

        

        tp_y


// Crear TP y l√≠neas basado en el input del usuario
if (bar_index > 10) // Asegurarse de que hay suficientes barras para calcular
    for i = 1 to numTP
        createTP(i)


        

// Funci√≥n para crear TP y l√≠neas
createTP2(level_info) =>
    if showLabel
        var float tp_y2 = na
        var string emoji = na

        if PercentOrATR == "PREDICTUM"
            if level_info == 1
                tp_y2 := (lastTrade(close) - lastTrade(atrStop)) * level_info + lastTrade(close)
            else
                tp_y2 := tp_y2 + (tp_y2 - lastTrade(close)) * 0.618  
            
            emoji := level_info == numTP ? "üé±üé±" : "üé±"
        else
            tp_y2 := (lastTrade(close) - lastTrade(atrStop)) * level_info + lastTrade(close)
            emoji := level_info == numTP ? "üé±üé±" : "üé±"

        // Agregar el resultado al texto de la etiqueta
        'TP ' + str.tostring(level_info) + ") "  + str.tostring(tp_y2, decimals) + " | "+ emoji + '\n'

if (bar_index > 10)
    for i = 1 to numTP
        // Llamar a la funci√≥n y agregar el resultado a buy_label
        buy_label := buy_label + createTP2(i)



buy_label := buy_label + 'StopLoss ‚õîÔ∏è: ' + '' + str.tostring(stop_y, decimals) +'\n'
buy_label := buy_label + ' \n' 

buy_label := buy_label + '=====Strategy======\n'
buy_label := buy_label + ' \n' 
buy_label := buy_label + 'Stop: Moving Target -\n'
buy_label := buy_label + '  Trigger: Target  ' + str.tostring((MovingTarget))+ '\n'
buy_label := buy_label + ' \n' 
buy_label := buy_label + 'Take profit strategy: ' + str.tostring((PercentOrATR))+ '\n' 
buy_label := buy_label + 'Indicator: ' + str.tostring((indicator_name))+ '\n'


lab_buy = label.new(bar_index - 15, showLabel ? close : na, buy_label, color=color.new(color.gray, 40), textcolor=color.white, style=label.style_label_down, yloc=yloc.abovebar, textalign=text.align_left)

// Mueve la etiqueta fuera del gr√°fico cuando no se muestra
//label.set_x(lab_buy, bar_index - 500)
if not showLabel
    label.delete(lab_buy)

label.delete(lab_buy[1])


//################################################################



//***************************************************************************** 
// Module  - Max Profit  by CoMgUnNeR 
//----------------------------------------- 
//********************************************************* 
//*                     Module                            * 
//*                   Max Profit                          * 
//********************************************************* 
// C√°lculos idea original de CoMgUnNeR 
//-------- 
// Grupo : Opciones del Module INFOBOX 
groupmaxprofit_maxpro = "====== Max Profit ======" 
// Separaci√≥n visual 
plot(na) 
 
///////////////////////////////////////////////////////////// 
// CONFIGURAR LAS ENTRADAS if (buy) if (sell) 
///////////////////////////////////////////////////////////// 
leverage_maxpro = input.int(title="Leverage x", defval=1, minval=1, maxval=125, group=groupmaxprofit_maxpro) 
levelsmaxpro = input(title='Show  Labels Max Profit / Mostrar Etiquetas  Max Profit', defval=false) 
yposmaxpro = input.int(title="Y Label Position Max Profit", defval=1, minval=1, maxval=10) 
 
lux_maxpro = #2157f370  //#ff5d0070  //#2157f370 //
 
var float longHigh_maxpro = 0.0 
var label longLabel_maxpro = na 
var label shortLabel_maxpro = na 
 
var float entryPrice_maxpro = na 
var float exitPrice_maxpro = na 
var float peakProfit_maxpro = na 
var string peakProfitString_maxpro = "" 
var float shortLow_maxpro = na 
 
 
if (bull) 
    shortLabel_maxpro := na 
    longHigh_maxpro := high 
    if levelsmaxpro == true 
        longLabel_maxpro := label.new(bar_index, high, str.tostring(high), color=lux_maxpro, textcolor=color.white) 
 
 
 
    // Guardar el precio de entrada al abrir una posici√≥n larga 
    entryPrice_maxpro := close 
 
if (high > longHigh_maxpro) 
    longHigh_maxpro := high 
    longLabel_maxpro.set_x(bar_index + yposmaxpro) 
    longLabel_maxpro.set_text(str.tostring(high)) 
    longLabel_maxpro.set_y(high) 
 
if (bear) 
    longLabel_maxpro := na 
    shortLow_maxpro := low 
    if levelsmaxpro == true 
        shortLabel_maxpro := label.new(bar_index, low, str.tostring(low), style=label.style_label_up, color=lux_maxpro, textcolor=color.white) 
 
    // Guardar el precio de entrada al abrir una posici√≥n corta 
    entryPrice_maxpro := close 
 
if (low < shortLow_maxpro) 
    shortLow_maxpro := low 
    shortLabel_maxpro.set_x(bar_index + yposmaxpro) 
    shortLabel_maxpro.set_text(str.tostring(low)) 
    shortLabel_maxpro.set_y(low) 
 
// Calcular el porcentaje de Peak Profit al cerrar la posici√≥n 
if (na(entryPrice_maxpro) == false) 
    // Guardar el precio de salida al cerrar la posici√≥n 
    exitPrice_maxpro := close 
 
    // Calcular el Peak Profit como porcentaje 
    peakProfit_maxpro := (((math.abs(exitPrice_maxpro - entryPrice_maxpro)) / entryPrice_maxpro) * 100) * leverage_maxpro 
    peakProfitString_maxpro := str.tostring(math.round(peakProfit_maxpro, 2)) 
 
    // Mostrar el Peak Profit en la etiqueta correspondiente 
    if (na(shortLabel_maxpro) == false) 
        label.set_text(shortLabel_maxpro, "Peak Profit: " + peakProfitString_maxpro + "%") 
    else 
        label.set_text(longLabel_maxpro, "Peak Profit: " + peakProfitString_maxpro + "%") 
 
//***************************************************************************** 
//MODO FACIL SIN PERSONALIZACION 
//import protradingart/pta_plot/6 as pp  
//pp.peakprofit(buy, sell) 
//https://www.tradingview.com/script/Bcm0mGop-pta-plot/ 
//Instruction: Don't forget to add ,max_labels_count=500, max_bars_back=500 
//*****************************************************************************

//
//SETTINGS
//

//      INDICATOR SETTINGS
swing_length = input.int(10, title = 'Swing High/Low Length', group = 'Settings', minval = 1, maxval = 50)
history_of_demand_to_keep = input.int(20, title = 'History To Keep', minval = 5, maxval = 50)
box_width = input.float(2.5, title = 'Supply/Demand Box Width', group = 'Settings', minval = 1, maxval = 10, step = 0.5)

//      INDICATOR VISUAL SETTINGS
show_zigzag = input.bool(false, title = 'Show Zig Zag', group = 'Visual Settings', inline = '1')
show_price_action_labels = input.bool(false, title = 'Show Price Action Labels', group = 'Visual Settings', inline = '2')

supply_color = input.color(color.new(#EDEDED,70), title = 'Supply', group = 'Visual Settings', inline = '3')
supply_outline_color = input.color(color.new(color.white,75), title = 'Outline', group = 'Visual Settings', inline = '3')

demand_color = input.color(color.new(#00FFFF,70), title = 'Demand', group = 'Visual Settings', inline = '4')
demand_outline_color = input.color(color.new(color.white,75), title = 'Outline', group = 'Visual Settings', inline = '4')

bos_label_color = input.color(color.white, title = 'BOS Label', group = 'Visual Settings', inline = '5')
poi_label_color = input.color(color.white, title = 'POI Label', group = 'Visual Settings', inline = '7')

swing_type_color = input.color(color.black, title = 'Price Action Label', group = 'Visual Settings', inline = '8')
zigzag_color = input.color(color.new(#000000,0), title = 'Zig Zag', group = 'Visual Settings', inline = '9')

//
//END SETTINGS
//


//
//FUNCTIONS
//

//      FUNCTION TO ADD NEW AND REMOVE LAST IN ARRAY
f_array_add_pop(array, new_value_to_add) =>
    array.unshift(array, new_value_to_add)
    array.pop(array)

//      FUNCTION SWING H & L LABELS
f_sh_sl_labels(array, swing_type) =>

    var string label_text = na
    if swing_type == 1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HH'
        else
            label_text := 'LH'
        label.new(bar_index - swing_length, array.get(array,0), text = label_text, style=label.style_label_down, textcolor = swing_type_color, color = color.new(swing_type_color, 100), size = size.tiny)
    
    else if swing_type == -1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HL'
        else
            label_text := 'LL'
        label.new(bar_index - swing_length, array.get(array,0), text = label_text, style=label.style_label_up, textcolor = swing_type_color, color = color.new(swing_type_color, 100), size = size.tiny)

//      FUNCTION MAKE SURE SUPPLY ISNT OVERLAPPING
f_check_overlapping(new_poi, box_array, atr) =>

    atr_threshold = atr * 2
    okay_to_draw = true

    for i = 0 to array.size(box_array) - 1
        top = box.get_top(array.get(box_array, i))
        bottom = box.get_bottom(array.get(box_array, i))
        poi = (top + bottom) / 2

        upper_boundary = poi + atr_threshold
        lower_boundary = poi - atr_threshold

        if new_poi >= lower_boundary and new_poi <= upper_boundary
            okay_to_draw := false
            break
        else 
            okay_to_draw := true
    okay_to_draw


//      FUNCTION TO DRAW SUPPLY OR DEMAND ZONE
f_supply_demand(value_array, bn_array, box_array, label_array, box_type, atr) =>

    atr_buffer = atr * (box_width / 10)
    box_left = array.get(bn_array, 0)
    box_right = bar_index

    var float box_top = 0.00
    var float box_bottom = 0.00
    var float poi = 0.00


    if box_type == 1
        box_top := array.get(value_array, 0)
        box_bottom := box_top - atr_buffer
        poi := (box_top + box_bottom) / 2
    else if box_type == -1
        box_bottom := array.get(value_array, 0)
        box_top := box_bottom + atr_buffer
        poi := (box_top + box_bottom) / 2

    okay_to_draw = f_check_overlapping(poi, box_array, atr)
    // okay_to_draw = true

    //delete oldest box, and then create a new box and add it to the array
    if box_type == 1 and okay_to_draw
        box.delete( array.get(box_array, array.size(box_array) - 1) )
        f_array_add_pop(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = supply_outline_color,
             bgcolor = supply_color, extend = extend.right, text = 'SUPPLY', text_halign = text.align_center, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))
        
        box.delete( array.get(label_array, array.size(label_array) - 1) )
        f_array_add_pop(label_array, box.new( left = box_left, top = poi, right = box_right, bottom = poi, border_color = color.new(poi_label_color,90),
             bgcolor = color.new(poi_label_color,90), extend = extend.right, text = 'POI', text_halign = text.align_left, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))

    else if box_type == -1 and okay_to_draw
        box.delete( array.get(box_array, array.size(box_array) - 1) )
        f_array_add_pop(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = demand_outline_color,
             bgcolor = demand_color, extend = extend.right,  text = 'DEMAND', text_halign = text.align_center, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))
        
        box.delete( array.get(label_array, array.size(label_array) - 1) )
        f_array_add_pop(label_array, box.new( left = box_left, top = poi, right = box_right, bottom = poi, border_color = color.new(poi_label_color,90),
             bgcolor = color.new(poi_label_color,90), extend = extend.right,  text = 'POI', text_halign = text.align_left, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))


//      FUNCTION TO CHANGE SUPPLY/DEMAND TO A BOS IF BROKEN
f_sd_to_bos(box_array, bos_array, label_array, zone_type) =>

    if zone_type == 1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_top(array.get(box_array,i))
            // if ta.crossover(close, level_to_break)
            if close >= level_to_break
                copied_box = box.copy(array.get(box_array,i))
                f_array_add_pop(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                box.set_top(array.get(bos_array,0), mid)
                box.set_bottom(array.get(bos_array,0), mid)
                box.set_extend( array.get(bos_array,0), extend.none)
                box.set_right( array.get(bos_array,0), bar_index)
                box.set_text( array.get(bos_array,0), 'BOS' )
                box.set_text_color( array.get(bos_array,0), bos_label_color)
                box.set_text_size( array.get(bos_array,0), size.small)
                box.set_text_halign( array.get(bos_array,0), text.align_center)
                box.set_text_valign( array.get(bos_array,0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))


    if zone_type == -1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_bottom(array.get(box_array,i))
            // if ta.crossunder(close, level_to_break)
            if close <= level_to_break
                copied_box = box.copy(array.get(box_array,i))
                f_array_add_pop(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                box.set_top(array.get(bos_array,0), mid)
                box.set_bottom(array.get(bos_array,0), mid)
                box.set_extend( array.get(bos_array,0), extend.none)
                box.set_right( array.get(bos_array,0), bar_index)
                box.set_text( array.get(bos_array,0), 'BOS' )
                box.set_text_color( array.get(bos_array,0), bos_label_color)
                box.set_text_size( array.get(bos_array,0), size.small)
                box.set_text_halign( array.get(bos_array,0), text.align_center)
                box.set_text_valign( array.get(bos_array,0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))



//      FUNCTION MANAGE CURRENT BOXES BY CHANGING ENDPOINT
f_extend_box_endpoint(box_array) =>

    for i = 0 to array.size(box_array) - 1
        box.set_right(array.get(box_array, i), bar_index + 100)


//
//END FUNCTIONS
//  


//
//CALCULATIONS
//

//      CALCULATE ATR 
atr = ta.atr(50)

//      CALCULATE SWING HIGHS & SWING LOWS
swing_high = ta.pivothigh(high, swing_length, swing_length)
swing_low = ta.pivotlow(low, swing_length, swing_length)

//      ARRAYS FOR SWING H/L & BN 
var swing_high_values = array.new_float(5,0.00)
var swing_low_values = array.new_float(5,0.00)

var swing_high_bns = array.new_int(5,0)
var swing_low_bns = array.new_int(5,0)

//      ARRAYS FOR SUPPLY / DEMAND
var current_supply_box = array.new_box(history_of_demand_to_keep, na)
var current_demand_box = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR SUPPLY / DEMAND POI LABELS
var current_supply_poi = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos = array.new_box(5, na)
var demand_bos = array.new_box(5, na)
//
//END CALCULATIONS
//

//      NEW SWING HIGH
if not na(swing_high)

    //MANAGE SWING HIGH VALUES
    f_array_add_pop(swing_high_values, swing_high)
    f_array_add_pop(swing_high_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_high_values, 1)

    f_supply_demand(swing_high_values, swing_high_bns, current_supply_box, current_supply_poi, 1, atr)

//      NEW SWING LOW
else if not na(swing_low)

    //MANAGE SWING LOW VALUES
    f_array_add_pop(swing_low_values, swing_low)
    f_array_add_pop(swing_low_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_low_values, -1)
    
    f_supply_demand(swing_low_values, swing_low_bns, current_demand_box, current_demand_poi, -1, atr)


f_sd_to_bos(current_supply_box, supply_bos, current_supply_poi, 1)
f_sd_to_bos(current_demand_box, demand_bos, current_demand_poi, -1)

f_extend_box_endpoint(current_supply_box)
f_extend_box_endpoint(current_demand_box)

//ZIG ZAG
h = ta.highest(high, swing_length * 2 + 1)
l = ta.lowest(low, swing_length * 2 + 1)
f_isMin(len) =>
    l == low[len]
f_isMax(len) =>
    h == high[len]

var dirUp = false
var lastLow = high * 100
var lastHigh = 0.0
var timeLow = bar_index
var timeHigh = bar_index
var line li = na

f_drawLine() =>
    _li_color = show_zigzag ? zigzag_color : color.new(#ffffff,100)
    line.new(timeHigh - swing_length, lastHigh, timeLow - swing_length, lastLow, xloc.bar_index, color=_li_color, width=2)

if dirUp
    if f_isMin(swing_length) and low[swing_length] < lastLow
        lastLow := low[swing_length]
        timeLow := bar_index
        line.delete(li)
        li := f_drawLine()
        li

    if f_isMax(swing_length) and high[swing_length] > lastLow
        lastHigh := high[swing_length]
        timeHigh := bar_index
        dirUp := false
        li := f_drawLine()
        li

if not dirUp
    if f_isMax(swing_length) and high[swing_length] > lastHigh
        lastHigh := high[swing_length]
        timeHigh := bar_index
        line.delete(li)
        li := f_drawLine()
        li
    if f_isMin(swing_length) and low[swing_length] < lastHigh
        lastLow := low[swing_length]
        timeLow := bar_index
        dirUp := true
        li := f_drawLine()
        if f_isMax(swing_length) and high[swing_length] > lastLow
            lastHigh := high[swing_length]
            timeHigh := bar_index
            dirUp := false
            li := f_drawLine()
            li
// if barstate.islast
    // label.new(x = bar_index + 10, y = close[1], text = str.tostring( array.size(current_supply_poi) ))
//     label.new(x = bar_index + 20, y = close[1], text = str.tostring( box.get_bottom( array.get(current_supply_box, 0))))
//     label.new(x = bar_index + 30, y = close[1], text = str.tostring( box.get_bottom( array.get(current_supply_box, 1))))
//     label.new(x = bar_index + 40, y = close[1], text = str.tostring( box.get_bottom( array.get(current_supply_box, 2))))
//     label.new(x = bar_index + 50, y = close[1], text = str.tostring( box.get_bottom( array.get(current_supply_box, 3))))
//     label.new(x = bar_index + 60, y = close[1], text = str.tostring( box.get_bottom( array.get(current_supply_box, 4))))
// End of Script
